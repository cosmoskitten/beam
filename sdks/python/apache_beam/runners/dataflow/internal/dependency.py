# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""Support for installing custom code and required dependencies.

Workflows, with the exception of very simple ones, are organized in multiple
modules and packages. Typically, these modules and packages have
dependencies on other standard libraries. Dataflow relies on the Python
setuptools package to handle these scenarios. For further details please read:
https://pythonhosted.org/an_example_pypi_project/setuptools.html

When a runner tries to run a pipeline it will check for a --requirements_file
and a --setup_file option.

If --setup_file is present then it is assumed that the folder containing the
file specified by the option has the typical layout required by setuptools and
it will run 'python setup.py sdist' to produce a source distribution. The
resulting tarball (a .tar or .tar.gz file) will be staged at the GCS staging
location specified as job option. When a worker starts it will check for the
presence of this file and will run 'easy_install tarball' to install the
package in the worker.

If --requirements_file is present then the file specified by the option will be
staged in the GCS staging location.  When a worker starts it will check for the
presence of this file and will run 'pip install -r requirements.txt'. A
requirements file can be easily generated by running 'pip freeze -r
requirements.txt'. The reason a Dataflow runner does not run this automatically
is because quite often only a small fraction of the dependencies present in a
requirements.txt file are actually needed for remote execution and therefore a
one-time manual trimming is desirable.

TODO(silviuc): Staged files should have a job specific prefix.
To prevent several jobs in the same project stomping on each other due to a
shared staging location.

TODO(silviuc): Should we allow several setup packages?
TODO(silviuc): We should allow customizing the exact command for setup build.
"""

import pkg_resources

from apache_beam import version as beam_version

# All constants are for internal use only; no backwards-compatibility
# guarantees.

# In a released SDK, container tags are selected based on the SDK version.
# Unreleased versions use container versions based on values of
# BEAM_CONTAINER_VERSION and BEAM_FNAPI_CONTAINER_VERSION (see below).

# Update this version to the next version whenever there is a change that will
# require changes to legacy Dataflow worker execution environment.
BEAM_CONTAINER_VERSION = 'beam-master-20180413'
# Update this version to the next version whenever there is a change that
# requires changes to SDK harness container or SDK harness launcher.
BEAM_FNAPI_CONTAINER_VERSION = 'beam-master-20180413'

# Standard file names used for staging files.
WORKFLOW_TARBALL_FILE = 'workflow.tar.gz'
REQUIREMENTS_FILE = 'requirements.txt'
EXTRA_PACKAGES_FILE = 'extra_packages.txt'

# Package names for different distributions
GOOGLE_PACKAGE_NAME = 'google-cloud-dataflow'
BEAM_PACKAGE_NAME = 'apache-beam'

# SDK identifiers for different distributions
GOOGLE_SDK_NAME = 'Google Cloud Dataflow SDK for Python'
BEAM_SDK_NAME = 'Apache Beam SDK for Python'

DATAFLOW_CONTAINER_IMAGE_REPOSITORY = 'dataflow.gcr.io/v1beta3'


def get_runner_harness_container_image():
  """For internal use only; no backwards-compatibility guarantees.

   Returns:
     str: Runner harness container image that shall be used by default
       for current SDK version or None if the runner harness container image
       bundled with the service shall be used.
  """
  # Pin runner harness for released versions of the SDK.
  if 'dev' not in beam_version.__version__:
    return (DATAFLOW_CONTAINER_IMAGE_REPOSITORY + '/' + 'harness' + ':' +
            beam_version.__version__)
  # Don't pin runner harness for dev versions so that we can notice
  # potential incompatibility between runner and sdk harnesses.
  return None


def get_default_container_image_for_current_sdk(job_type):
  """For internal use only; no backwards-compatibility guarantees.

  Args:
    job_type (str): BEAM job type.

  Returns:
    str: Google Cloud Dataflow container image for remote execution.
  """
  # TODO(tvalentyn): Use enumerated type instead of strings for job types.
  if job_type == 'FNAPI_BATCH' or job_type == 'FNAPI_STREAMING':
    image_name = DATAFLOW_CONTAINER_IMAGE_REPOSITORY + '/python-fnapi'
  else:
    image_name = DATAFLOW_CONTAINER_IMAGE_REPOSITORY + '/python'
  image_tag = _get_required_container_version(job_type)
  return image_name + ':' + image_tag


def _get_required_container_version(job_type=None):
  """For internal use only; no backwards-compatibility guarantees.

  Args:
    job_type (str, optional): BEAM job type. Defaults to None.

  Returns:
    str: The tag of worker container images in GCR that corresponds to
      current version of the SDK.
  """
  if 'dev' in beam_version.__version__:
    if job_type == 'FNAPI_BATCH' or job_type == 'FNAPI_STREAMING':
      return BEAM_FNAPI_CONTAINER_VERSION
    else:
      return BEAM_CONTAINER_VERSION
  else:
    return beam_version.__version__


def get_sdk_name_and_version():
  """For internal use only; no backwards-compatibility guarantees.

  Returns name and version of SDK reported to Google Cloud Dataflow."""
  try:
    pkg_resources.get_distribution(GOOGLE_PACKAGE_NAME)
    return (GOOGLE_SDK_NAME, beam_version.__version__)
  except pkg_resources.DistributionNotFound:
    return (BEAM_SDK_NAME, beam_version.__version__)


def get_sdk_package_name():
  """For internal use only; no backwards-compatibility guarantees.

        Returns the PyPI package name to be staged to Google Cloud Dataflow."""
  sdk_name, _ = get_sdk_name_and_version()
  if sdk_name == GOOGLE_SDK_NAME:
    return GOOGLE_PACKAGE_NAME
  else:
    return BEAM_PACKAGE_NAME
