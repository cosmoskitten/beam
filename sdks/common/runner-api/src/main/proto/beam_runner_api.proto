/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Protocol Buffers describing the Runner API, which is the runner-independent,
 * SDK-independent definition of the Beam model.
 */

syntax = "proto3";

package org.apache.beam.runner_api.v1;

option java_package = "org.apache.beam.sdks.common.runner_api.v1";
option java_outer_classname = "RunnerApi";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

// A Pipeline contains the entire hierarchical graph of transforms as well
// as descriptors for all PCollections.
//
// The hierarchical graph itself is an independent layer from the payloads
// specific to the Runner API, for ease of reuse by e.g. the Fn API.
message Pipeline {

  // (Required) A map from pipeline-scoped id to graph node.
  //
  // Each node is required to contain a PTransform specification.
  map<int64, GraphNode> transform_nodes = 1;

  // (Required) A map from pipeline-scoped id to PCollection.
  map<int64, PCollection> pcollections = 2;

  // (Required) A map from pipeline-scoped id to WindowingStrategy.
  map<int64, WindowingStrategy> windowing_strategies = 3;

  // (Required) A map from pipeline-scoped id to Coder.
  map<int64, Coder> coders = 4;

  // (Required) A map from pipeline-scoped id to Environment.
  map<int64, Environment> environments = 5;

  // (Optional) Static display data for the pipeline.
  DisplayData display_data = 7;
}

// A generic node in a bipartite directed hierarchical graph.
message GraphNode {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) A URN that describes what kind graph node this is.
  //
  // Specifically, the URN should be enough to decipher the inputs,
  // outputs, and payload.
  string urn = 2;

  // (Optional) if this node is contained within a composite, a pointer to the
  // parent.
  int64 parent_ref = 3;

  // (Required) A map of local input names to target definitions.
  //
  // The URN for the graph node may clarify the type of the inputs
  // (resp. outputs). For example:
  //
  //  - in the Runner API these are PCollections
  //  - in the Fn API they may be Grpc ports
  //
  // The payload for this graph node may clarify the relationship of these
  // inputs. For example:
  //
  //  - for a Flatten transform they are merged
  //  - for a ParDo transform, some may be side inputs
  //
  // All inputs are recorded here so that the topological ordering of
  // the graph is consistent whether or not the payload is understood.
  //
  // TODO: fix the value to be int64 as they will always be refs?
  map<string, google.protobuf.Any> inputs = 4;

  // (Required) A map from local output name to PCollection definitions.
  //
  // The URN or payload for the graph node may clarify the type and
  // relationship of these. For example:
  //
  //  - for a ParDo transform, these are tags on PCollections, which will be
  //    embedded in the DoFn.
  //  - in the Runner API the targets are PCollections
  //  - in the Fn API the targets may be Grpc ports
  //
  // TODO: fix the value to be int64 as they will always be refs?
  map<string, google.protobuf.Any> outputs = 5;

  // (Required) A payload determined by the URN, fully specifying this node.
  google.protobuf.Any payload = 6;
}

// A PCollection!
message PCollection {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) A unique program-readable name for the value, such as
  // "foo/baz/bar.out"
  string label = 2;

  // (Required) The id of the Coder for this PCollection.
  int64 coder_ref = 3;

  // (Required) Whether this PCollection is bounded or unbounded
  IsBounded is_bounded = 4;

  // (Required) The id of the windowing strategy for this PCollection.
  int64 windowing_strategy_ref = 5;

  // (Optional) Static display data for this PCollection.
  DisplayData display_data = 6;
}

// An applied PTransform! This does not contain the graph data, but only the
// fields specific to a graph node that is a Runner API transform
// between PCollections.
message PTransform {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) A unique name for the application node.
  //
  // This should be stable over multiple runs of a driver program for the
  // purposes of logging and associating pipeline state with a node.
  string label = 2;

  // (Optional) A URN that identifies what type of transform this is.
  //
  // If absent, this must be an "anonymous" composite transform.
  //
  // If present, this URN should suffice to understand the payload and
  // the two together should fully specify the SDK-independent and
  // runner-independent semantics of the transform.
  string urn = 3;

  // (Optional) An arbitrary payload whose schema is determined by the URN.
  //
  // For primitive transform in the Runner API, the payload is well defined:
  //
  //  - when the URN is "urn:beam:transforms:pardo" it is a ParDoPayload
  //  - when the URN is "urn:beam:transforms:read" it is a ReadPayload
  //  - when the URN is "urn:beam:transforms:gbk" it is a GroupByKeyPayload
  //  - when the URN is "urn:beam:transforms:window" it is a WindowPayload
  //  - when the URN is "urn:beam:transforms:flatten" it is absent
  //
  // For some special composite transforms, the payload is also well-defined:
  //
  //  - when the URN is "urn:beam:transforms:combine" it is a CombinePayload
  //
  // For other composites, the payload will often be absent.
  //
  // TODO: duplicate PTransform's fields into each Payload to save indirection?
  google.protobuf.Any payload = 4;

  // (Optional) Static display data for this PTransform application.
  DisplayData display_data = 6;
}

// The payload for the primitive ParDo transform.
message ParDoPayload {

  // (Required) The DoFn for this ParDo.
  FunctionSpec do_fn = 1;

  // (Required) Whether the DoFn requires access to the current window (this
  // may force runners to perform additional work prior to executing this ParDo)
  //
  // TODO: consider a DoFnPayload that holds these facts common to all DoFns
  repeated DoFnContext required_context = 2;

  // (Optional) A map from local input name to the specification for how to
  // materialize and read it as a side input
  map<string, SideInput> side_inputs = 3;

  // (Optional) if the DoFn uses state, a map from id to the spec for the
  // state cell.
  map<string, StateSpec> state_specs = 4;

  // (Optional) if the DoFn uses timers, a map from id to the spec for the
  // timer.
  map<string, TimerSpec> timer_specs = 5;

  // Requirements on the context a DoFn might require that are not otherwise
  // represented in the signature here.
  enum DoFnContext {
    WINDOW_ACCESS = 0;
  }
}


message StateSpec {
  // TODO: AST for state spec
}

message TimerSpec {
  // TODO: AST for timer spec
}

enum IsBounded {
  BOUNDED = 0;
  UNBOUNDED = 1;
}

// The payload for the primitive Read transform.
//
// TODO: audit what needs to be in this payload
message ReadPayload {

  // (Required) The source for this Read
  FunctionSpec source = 1;

  // (Required) Whether the source is bounded or unbounded
  IsBounded is_bounded = 2;

  // TODO: consider other methods such as doesNotRequireSplitting() and producesSortedKeys()
  // what else?
}

// The payload for the Window transform.
//
// TODO: consider making this non-primitive according to BEAM-<issue #>
message WindowIntoPayload {
  // (Required) the window fn for assigning windows
  FunctionSpec window_fn = 1;
}

// The payload for the non-primitive Combine transform.
message CombinePayload {

  // (Required) The CombineFn for this Combine
  FunctionSpec combine_fn = 1;

  // (Required) A reference to the Coder to use for accumulators of the CombineFn
  int64 accumulator_coder_ref = 2;

  // (Optional) if the CombineFn uses side inputs, a map from the id to the spec
  // for how to materialize and read the PCollection as a side input
  map<string, SideInput> side_inputs = 3;
}

// A coder, the binary format for serialization and deserialization of data in
// a pipeline.
message Coder {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) A cross-language, stable, unique identifier for the (possibly
  // parametric) encoding.
  string urn = 2;

  // (Optional) If this coder is parametric, such as ListCoder(VarIntCoder),
  // this is a list of the components. In order for encodings to be identical,
  // the URN and all components must be identical, recursively.
  repeated int64 component_coder_reference = 3;

  // (Optional) An SDK-specific UDF implementing the coder.
  //
  // TODO: reconsider how to do this, aka CustomCoder
  FunctionSpec custom_coder_fn = 4;
}

// A windowing strategy describes the window function, triggering, allowed
// lateness, and accumulation mode for a PCollection.
//
// TODO: consider inlining field on PCollection if they aren't really a coherent whole
message WindowingStrategy {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) The UDF assigns windows, merges windows, and shifts timestamps
  // before they are combined according to the OutputTime.
  FunctionSpec window_fn = 2;

  // (Required) Whether or not the window fn is merging.
  //
  // This knowledge is required for many optimizations.
  MergeStatus merge_status = 3;

  // (Required) The coder for the windows of this PCollection.
  int64 window_coder_reference = 4;

  // (Required) The trigger, serialized as a simple syntax tree.
  //
  // TODO: say more
  Trigger trigger = 5;

  // (Required) The accumulation mode indicates whether new panes are a full
  // replacement for prior panes or whether they are deltas to be combined
  // with other panes (the combine should correspond to whatever the upstream
  // grouping transform is).
  AccumulationMode accumulation_mode = 6;

  // (Required) The OutputTime specifies, for a grouping transform, how to
  // compute the aggregate timestamp. The window_fn will first possibly shift
  // it later, then the OutputTime takes the max, min, or ignores it and takes
  // the end of window.
  //
  // This is actually only for input to grouping transforms, but since they
  // may be introduced in runner-specific ways, it is carried along with the
  // windowing strategy.
  OutputTime output_time = 7;

  // (Required) The duration beyond the end of a window at which the window becomes droppable.
  int64 allowed_lateness = 8;
}

enum MergeStatus {
  NON_MERGING = 0;
  NEEDS_MERGE = 1;
  ALREADY_MERGED = 2;
}

enum AccumulationMode {
  DISCARDING = 0;
  ACCUMULATING = 1;
}

enum OutputTime {
  END_OF_WINDOW = 0;
  LATEST_IN_PANE = 1;
  EARLIEST_IN_PANE = 2;
}

message Trigger {
  message AfterAll {
    repeated Trigger sub_trigger = 1;
  }

  message AfterAny {
    repeated Trigger sub_trigger = 1;
  }

  message AfterEach {
    repeated Trigger sub_trigger = 1;
  }

  message AfterEndOfWindow {
    // Optional
    Trigger early_firings = 1;

    // Optional
    Trigger late_firings = 2;
  }

  message AfterProcessingTimeDelay {
    int64 delay_millis = 1;
  }

  message AfterSynchronizedProcessingTimeDelay {
    int64 delay_millis = 1;
  }

  message Never { }

  message Repeat {
    Trigger sub_trigger = 1;
  }

  message OrFinally {
    Trigger main = 1;
    Trigger finally = 2;
  }

  message Default { }

  oneof trigger {
    AfterAll after_all = 1;
    AfterAny after_any = 2;
    AfterEach after_each = 3;
    AfterEndOfWindow after_end_of_widow = 4;
    AfterProcessingTimeDelay after_processing_time_delay = 5;
    AfterSynchronizedProcessingTimeDelay after_synchronized_processing_time_delay = 6;
    Never never = 7;
    Repeat repeat = 8;
    OrFinally or_finally = 9;
    Default default = 10;
  }
}

// A specification for how to "side input" a PCollection.
message SideInput {

  // (Required) URN of the access pattern required by the `view_fn` to present
  // the desired SDK-specific interface to a UDF.
  //
  // This access pattern defines the SDK harness <-> Runner Harness RPC
  // interface for accessing a side input.
  //
  // Pre-Beam View transforms implicitly always used the access pattern
  // "iterable", which presents an entire window of a PCollection as an
  // iterable for the view_fn to convert to the desired type.
  //
  // The only access pattern intended for Beam, because of its superior
  // performance possibilities, is "urn:beam:sideinput:multimap" (or some such
  // URN)
  string access_pattern = 1;

  // (Required) A UDF that adapts a particular access_pattern to a user-facing
  // view type.
  //
  // For example, View.asSingleton() may include a `view_fn` that adapts a
  // specially-designed multimap to a single value per window.
  //
  // TODO: this will actually be reused a lot; consider making it by reference
  FunctionSpec view_fn = 2;

  // (Required) A UDF that maps a main input window to a side input window.
  //
  // For example, when the main input is in fixed windows of one hour, this
  // can specify that the side input should be accessed according to the day
  // in which that hour falls.
  FunctionSpec window_mapping_fn = 3;
}

// An environment for executing UDFs. Generally an SDK container URL, but
// there can be many for a single SDK, for example to provide dependency
// isolation.
message Environment {

  // (Required) A pipeline-scoped unique id for this node
  int64 id = 1;

  // (Required) The URL of a container
  //
  // TODO: reconcile with Fn API's DockerContainer structure by
  // adding adequate metadata to know how to interpret the container
  string url = 2;
}

// Description of a user-defined function, including the environment/SDK in
// which to execute it
message FunctionSpec {

  // (Required) A pipeline-scoped unique id for this node.
  int64 id = 1;

  // (Required) A cross-language, stable, unique identifier for the function.
  //
  // The `payload` field should be understandable by any entity familiar with
  // the URN, with no insight into the completely opaque `data` blob. Together,
  // the URN and the payload should suffice for optimization or language-to-
  // language replacement.
  //
  // For example the distinguished urn "urn:beam:windowfn:FixedWindows" with
  // payload `{ duration: n }` fully specifies a windowing function which can
  // be implemented by the SDK constructing the pipeline, by another SDK (for
  // language-to-language fusion compatibility) or by the runner directly.
  string urn = 2;

  // (Required) Reference to the specification of the execution environment
  // required to invoke this function.
  int64 environment_reference = 3;

  // (Optional) If present, a payload whose schema is determined by the URN of
  // this function.
  google.protobuf.Any payload = 4;

  // (Required) The raw data of the function that the SDK knows how to
  // deserialize, but need not be comprehensible to any other runner, SDK, or
  // other entity.
  google.protobuf.Any data = 5;
}

// TODO: transfer javadoc here
message DisplayData {

  // Map keys cannot be messages, so the Identifier needs to be flattened to a string
  map<string, Item> items = 1;

  message Identifier {
    repeated string path = 1;
    string namespace = 2;
    string key = 3;
  }

  message Item {
    Identifier id = 1;
    Type type = 2;
    google.protobuf.Any value = 3;
    google.protobuf.Any short_value = 4;
    string label = 5;
    string link_url = 6;
  }

  enum Type {
    STRING = 0; INTEGER = 1; FLOAT = 2; BOOLEAN = 3; TIMESTAMP = 4; DURATION = 5; JAVA_CLASS = 6;
  }
}
